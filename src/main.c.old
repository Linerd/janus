#include <stdint.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>

#include "algo/maxmin.h"
#include "network.h"

#include "util/error.h"
#include "util/log.h"

#include "parse.h"
#include "dataplane.h"

#define MAX_FILE_SIZE (1 << 20) * sizeof(char)
void read_file(char const *file, char **output) {
  FILE *f = fopen(file, "r+");
  if (!f) {
    return;
  }

  *output = malloc(MAX_FILE_SIZE);
  memset(*output, 0, MAX_FILE_SIZE);
  int nread = fread(*output, 1, MAX_FILE_SIZE, f);

  if (nread >= MAX_FILE_SIZE) {
    panic("file size too large (> %d bytes).", MAX_FILE_SIZE);
  }
  fclose(f);
}

void network_free(struct dataplane_t *network) {
  if (network->routing) {
    free(network->routing);
    network->routing = 0;
  }

  if (network->links) {
    for (int i = 0; i < network->num_links; ++i) {
      free(network->links[i].flows);
    }
    free(network->links);
    network->links = 0;
  }

  if (network->flows) {
    free(network->flows);
    network->flows = 0;
  }
}

void network_slo_violation(struct dataplane_t *network, double y) {
  struct flow_t *flow = 0;
  int vio_num = 0;
  for (int i = 0; i < network->num_flows; ++i) {
    flow = &network->flows[i];
    if ((flow->demand > flow->bw) && (flow->bw < y)) {
        vio_num += 1;
    }
    if ((flow->demand < flow->bw)) {
        printf("Wierd");
    }
  }
  //printf("%d ToR pairs violating %f bandwidth, %d ToR pairs permitted\n", vio_num, y, x);
  printf("%d", vio_num);
}

const char *usage_message = "" \
  "usage: %s <routing-file> <slo-threshold>\n" \
  "routing-file has the following format:\n\n" \
  "\tr\n"\
  "\t[num-flows]\n"\
  "\t[links on path of flow 0]\n"\
  "\t[links on path of flow 1]\n"\
  "\t[...]\n"\
  "\t[links on path of flow n]\n"\
  "\tl\n"\
  "\t[link capacities, space separated]\n"\
  "\tf\n"\
  "\t[flow demands, space separated]\n\n";

void usage(const char *fname) {
  printf(usage_message, fname);
  exit(EXIT_FAILURE);
}

int main(int argc, char **argv) {
  char *output = 0;
  int err = 0;

  if (argc < 3) {
    usage(argv[0]);
  }

  info("reading data file.");
  read_file(argv[1], &output);

  struct dataplane_t network = {0};
  if ((err = parse_input(output, &network)) != E_OK) {
    error("failed to read the data file: %d.", err);
    return EXIT_FAILURE;
  };


  maxmin(&network);
  network_slo_violation(&network, atof(argv[2]));
  network_free(&network);

  return EXIT_SUCCESS;
}

/** long term gen **/
struct _rvar_cache_builder_parallel {
  struct traffic_matrix_trace_t *trace;
  uint32_t index;
  struct freelist_repo_t *network_freelist;
  pthread_mutex_t *lock;
};


struct _network_dp_t {
  struct dataplane_t dp;
  struct network_t *net;
};

rvar_type_t _sim_network_for_trace_parallel(void *data) {
  struct _rvar_cache_builder_parallel* builder = (struct _rvar_cache_builder_parallel*)data;
  struct traffic_matrix_t *tm = 0;
  trace_time_t time = 0;

  {
    // Get the next traffic matrix
    pthread_mutex_lock(builder->lock);

    traffic_matrix_trace_get_nth_key(builder->trace, builder->index, &time);
    traffic_matrix_trace_get(builder->trace, time, &tm);
    pthread_mutex_unlock(builder->lock);
  }

  int violations = 0;
  {
    // Simulate the network
    struct _network_dp_t *np = freelist_get(builder->network_freelist);
    np->net->set_traffic(np->net, tm);
    np->net->get_dataplane(np->net, &np->dp);

    maxmin(&np->dp);
    violations = dataplane_count_violations(&np->dp, 0);
    freelist_return(builder->network_freelist, np);
  }

  // Count the violations
  rvar_type_t percentage = (rvar_type_t)violations/(rvar_type_t)(tm->num_pairs);

  // And free the traffic matrix
  traffic_matrix_free(tm);

  return percentage;
}


void test_build_rvar_cache_parallel(struct expr_t *expr) {
  struct jupiter_switch_plan_enumerator_t *en = 
    jupiter_switch_plan_enumerator_create(
        expr->upgrade_list.num_switches,
        expr->located_switches,
        expr->upgrade_freedom,
        expr->upgrade_nfreedom);

  struct traffic_matrix_trace_t *trace = traffic_matrix_trace_load(400, expr->traffic_test);
  struct plan_iterator_t *iter = en->iter((struct plan_t *)en);
  int subplan_count = iter->subplan_count(iter);
  pthread_mutex_t mut;

  if (pthread_mutex_init(&mut, 0) != 0)
    panic("Couldn't initiate the mutex.");

  uint32_t trace_length = trace->num_indices;
  uint32_t nthreads = get_ncores() - 1;
  struct freelist_repo_t *repo = freelist_create(nthreads);
  struct _network_dp_t *networks = malloc(sizeof(struct _network_dp_t) * nthreads);

  for (uint32_t i = 0; i < nthreads; ++i) {
    networks[i].net = expr->clone_network(expr);
    memset(&networks[i].dp, 0, sizeof(struct dataplane_t));
    freelist_return(repo, &networks[i]);
  }

  for (int i = 0; i < subplan_count-1; ++i) {
    // Apply the mop on the network
    struct mop_t *mop = iter->mop_for(iter, i);
    struct _rvar_cache_builder_parallel *data = 
      malloc(sizeof(struct _rvar_cache_builder_parallel) * trace_length);

    for (uint32_t j = 0; j < nthreads; ++j) {
      mop->pre(mop, networks[j].net);
    }

    for (uint32_t j = 0; j < trace_length; ++j ){
      data[j].lock = &mut;
      data[j].trace = trace;
      data[j].index = j;
      data[j].network_freelist = repo;
    }

    struct rvar_t *rvar = (struct rvar_t *)rvar_monte_carlo_parallel(
        _sim_network_for_trace_parallel, 
        data, trace_length,
        sizeof(struct _rvar_cache_builder_parallel), 0);

    for (uint32_t j = 0; j < nthreads; ++j) {
      mop->post(mop, networks[j].net);
    }

    info("Generated rvar for %ith subplan (expected viol: %f)", i, rvar->expected(rvar));
    free(mop);
  }

  // Free the free list of networks
  for (uint32_t i = 0; i < nthreads; ++i) {
    struct _network_dp_t *np = freelist_get(repo);
    dataplane_free_resources(&np->dp);
  }
  free(networks);
  freelist_free(repo);

  traffic_matrix_trace_free(trace);
  info("Done generating the rvars");
}
